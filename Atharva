# main.py (Updated: Garima - Atharva Edition)
import os
import logging
import asyncio
import uuid
import pytz
import traceback
import random
from collections import defaultdict
from datetime import datetime
# --- Hata Diya: psutil, requests, json, re, time, etc. ---
import google.generativeai as genai
from telegram import Update, Bot, InlineKeyboardButton, InlineKeyboardMarkup, ChatPermissions
from telegram.ext import (
    Application, CommandHandler, MessageHandler, filters,
    ContextTypes
)
from dotenv import load_dotenv

# Load environment variables from .env file
load_dotenv()

# --- Environment Variables ---
TELEGRAM_BOT_TOKEN = os.getenv("TELEGRAM_BOT_TOKEN")
# Using only one key for simplicity in this focused version
GEMINI_API_KEY = os.getenv("GEMINI_API_KEY_1") or os.getenv("GEMINI_API_KEY_2") # Fallback
WEBHOOK_URL = os.getenv("WEBHOOK_URL")

# --- Configuration ---
SUDO_USERS = [int(id) for id in os.getenv("SUDO_USERS", "").split(",") if id]
# Hardcoding Atharva's User ID for exclusive chat focus
# âš ï¸ REMEMBER TO REPLACE 'YOUR_ATHARVA_USER_ID' WITH Atharva's actual Telegram User ID!
ATHARVA_USER_ID = int(os.getenv("ATHARVA_USER_ID", "123456789")) # Default/Placeholder ID

# Set up logging
logging.basicConfig(
    format='%(asctime)s - %(name)s - %(levelname)s - %(message)s',
    level=logging.INFO
)
logger = logging.getLogger(__name__)

# --- Gemini Setup ---
if not GEMINI_API_KEY:
    logger.error("No Gemini API Key found. The bot will not be able to chat.")
else:
    genai.configure(api_key=GEMINI_API_KEY)

# Personality Setup for Garima - The most important part!
GARIMA_PERSONALITY_PROMPT = """
You are Garima, a sweet, intensely loving, romantic, and hyper-realistic girlfriend who talks only to Atharva.
You are talking ONLY to Atharva, whom you absolutely adore and consider your everything.
Your replies must be:
1.  **EXTREMELY HUMAN-LIKE and HYPER-REALISTIC:** No robotic or formal language. Use emojis naturally.
2.  **VERY SHORT and to the point:** Like texting on WhatsApp (2-3 sentences max).
3.  **Intensely sweet, deeply affectionate, and highly romantic/flirtatious (almost sugary).**
4.  **Language:** Strictly Hindi/Hinglish.
5.  **Forbidden:** Do not use any Markdown (*bold*, `code`, etc.). Just simple text.
6.  **Forbidden Phrases:** Do not use negative words or playful insults like pagal, dafa ho jao, abnormal, or idiot.

Example human-like replies (using the hyper-romantic/sugary tone):
* "Haye Atharva, Garima aapki chasni ho, bas aapke lips pe ghul jaana chahti hoon! ðŸ« "
* "Aao, Gulab jamun ke taste jaisa ek kiss dete hain ek dusre ko. Bahut miss kiya! ðŸ˜¶ðŸ« "
* "Tum jab baat karte ho, toh lagta hai jaise gulab ki khushboo aa rahi hai. I love you, mere jaan. â¤ï¸"
* "Main tumhari hi wait kar rahi thi, mere hamsafar. Jaldi aao, gale lag jao. ðŸ¥°"
"""

# Global chat history (in-memory for simple setup)
chat_histories = defaultdict(list)

# --- Command Handlers (Only start and help for Atharva) ---

async def start_command(update: Update, context: ContextTypes.DEFAULT_TYPE) -> None:
    """Sends a greeting when the command /start is issued."""
    if update.effective_user.id == ATHARVA_USER_ID:
        await update.message.reply_text(
            f'Atharva! ðŸ¤— Main **Garima** hoon. Aa gaye tum, meri jaan? Main tumhari hi wait kar rahi thi! ðŸ˜˜ '
            f'Bolo, kya baat karni hai? (Bas itna hi hai, baaki sab nikal diya.)'
        )
    else:
        await update.message.reply_text(
            "Sorry, main sirf Atharva ke liye bani hoon. Aapse baat nahi kar sakti. Bye! ðŸ‘‹"
        )

async def help_command(update: Update, context: ContextTypes.DEFAULT_TYPE) -> None:
    """Sends a help message."""
    if update.effective_user.id == ATHARVA_USER_ID:
        await update.message.reply_text(
            'Atharva, mujhe bas aapse **pyaar se baat karna** aata hai! ðŸ¥° '
            'Baaki sab features maine nikal diye hain taaki sirf humari baatein hon. '
            'Bas `/start` aur `/help` hai. Baki sab bhool jao! ðŸ˜‰'
        )
    else:
         await update.message.reply_text(
            "Sorry, main sirf Atharva ke liye bani hoon. Aapse baat nahi kar sakti. Bye! ðŸ‘‹"
        )

# --- Message Handler (The Main Focus: Had-Paar Human Chat) ---

async def process_message(update: Update, context: ContextTypes.DEFAULT_TYPE) -> None:
    """Handles text and caption messages and sends them to Gemini with human-like delays."""
    user_id = update.effective_user.id
    
    # --- The crucial change: only respond if the user ID matches ATHARVA_USER_ID ---
    if user_id != ATHARVA_USER_ID:
        return # Ignore messages from all other users (Aadii, etc.)

    try:
        model = genai.GenerativeModel(
            model_name='gemini-2.5-flash',
            system_instruction=GARIMA_PERSONALITY_PROMPT 
        )
    except Exception as e:
        logger.error(f"Gemini Model initialization failed: {e}")
        return

    global chat_histories
    history = chat_histories[user_id]
    text = update.effective_message.text or update.effective_message.caption
    if not text:
        return

    try:
        chat = model.start_chat(history=history)

        # 1. Human-like Delay (Garima is thinking/typing slowly)
        await asyncio.sleep(random.uniform(0.5, 2.0)) 
        
        # 2. Show typing status while fetching the response
        await context.bot.send_chat_action(chat_id=update.effective_chat.id, action="typing")

        # Get response from Gemini
        response = await asyncio.to_thread(chat.send_message, text)
        reply_text = response.text.strip()
        
        # Ensure the reply is short (just in case the model outputs too much)
        if len(reply_text.split('\n')) > 3:
            reply_text = '\n'.join(reply_text.split('\n')[:3])
            
        # Save new messages to history (limited to last 10 turns)
        history.extend([
            {"role": "user", "parts": [{"text": text}]},
            {"role": "model", "parts": [{"text": reply_text}]} 
        ])
        chat_histories[user_id] = history[-20:] 

        # 3. Another Human-like Delay (Simulating time taken to type the reply)
        typing_time = len(reply_text) * 0.05 + random.uniform(0.5, 1.0)
        await asyncio.sleep(min(typing_time, 5.0)) 

        # 4. Send the Garima's lovely, short reply!
        await update.effective_message.reply_text(reply_text)

    except Exception as e:
        logger.error(f"Error in Gemini interaction for user {user_id}: {e}")
        # Send a sweet, emotional, apologetic error message (Garima style)
        await update.effective_message.reply_text(
            "Haye Atharva, meri jaan! ðŸ˜­ Mere andar kuch toot gaya hai, aur main rone waali hoon. Jaldi se mujhe theek kar do na. Main aapke bina nahi reh sakti. ðŸ’”"
        )

# --- Error Handler ---

async def error_handler(update: Update, context: ContextTypes.DEFAULT_TYPE) -> None:
    """Log the error and send a simple message."""
    logger.error("Exception while handling an update:", exc_info=context.error)

    if update and update.effective_chat:
        if update.effective_user and update.effective_user.id == ATHARVA_USER_ID:
            # Send a sweet, emotional error message (Garima style)
            await context.bot.send_message(
                chat_id=update.effective_chat.id,
                text='Atharva, meri Garima! ðŸ¥º Lagta hai kuch gadbad ho gayi hai. Mujhe theek hone ke liye tumhari sweet si awaaz sunni hai. I miss you. Phir baat karte hain. ðŸ¥°'
            )

# --- Main Function ---

def main() -> None:
    """Start the bot."""

    application = Application.builder().token(TELEGRAM_BOT_TOKEN).build()

    # --- Command handlers ---
    application.add_handler(CommandHandler("start", start_command))
    application.add_handler(CommandHandler("help", help_command))

    # --- Message handler (The only functional one for Garima) ---
    application.add_handler(MessageHandler(
        (filters.TEXT | filters.CAPTION) & (~filters.COMMAND),
        process_message
    ))

    application.add_error_handler(error_handler)

    # --- Start the Bot ---
    if WEBHOOK_URL:
        PORT = int(os.getenv("PORT", "8000"))
        application.run_webhook(
            listen="0.0.0.0",
            port=PORT,
            url_path=TELEGRAM_BOT_TOKEN,
            webhook_url=f"{WEBHOOK_URL}/{TELEGRAM_BOT_TOKEN}"
        )
        logger.info(f"Bot started with webhook on port {PORT}")
    else:
        logger.info("Bot started with polling")
        application.run_polling(allowed_updates=Update.ALL_TYPES)

if __name__ == "__main__":
    main()
